"use strict";exports.id=298,exports.ids=[298],exports.modules={26298:(fe,H,h)=>{h.d(H,{fromHttp:()=>ce});var B=h(8818),A=h(25317),p=h(35406),P=h(91943),$=h.n(P);const de="127.0.0.0/8",he="::1/128",W="169.254.170.2",D="169.254.170.23",F="[fd00:ec2::23]",K=(e,t)=>{if(e.protocol!=="https:"&&!(e.hostname===W||e.hostname===D||e.hostname===F)){if(e.hostname.includes("[")){if(e.hostname==="[::1]"||e.hostname==="[0000:0000:0000:0000:0000:0000:0000:0001]")return}else{if(e.hostname==="localhost")return;const r=e.hostname.split("."),o=n=>{const s=parseInt(n,10);return 0<=s&&s<=255};if(r[0]==="127"&&o(r[1])&&o(r[2])&&o(r[3])&&r.length===4)return}throw new p.C1(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`,{logger:t})}};var M=h(81701),z=h(80870),C=h(64198),j=h(9379);function le(e,t="utf-8"){return t==="base64"?toBase64(e):toUtf8(e)}function me(e,t){return t==="base64"?Uint8ArrayBlobAdapter.mutate(fromBase64(e)):Uint8ArrayBlobAdapter.mutate(fromUtf8(e))}class R extends null{static fromString(t,r="utf-8"){switch(typeof t){case"string":return transformFromString(t,r);default:throw new Error(`Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`)}}static mutate(t){return Object.setPrototypeOf(t,R.prototype),t}transformToString(t="utf-8"){return transformToString(this,t)}}var g=h(2203);const pe=(e,t)=>{const{base64Encoder:r,bodyLengthChecker:o,checksumAlgorithmFn:n,checksumLocationName:s,streamHasher:i}=t,c=r!==void 0&&n!==void 0&&s!==void 0&&i!==void 0,u=c?i(n,e):void 0,a=new Readable({read:()=>{}});return e.on("data",f=>{const l=o(f)||0;a.push(`${l.toString(16)}\r
`),a.push(f),a.push(`\r
`)}),e.on("end",async()=>{if(a.push(`0\r
`),c){const f=r(await u);a.push(`${s}:${f}\r
`),a.push(`\r
`)}a.push(null)}),a};var G=h(82923),Z=h(39023);const T={supported:void 0};class v{static create(t){return typeof t?.handle=="function"?t:new v(t)}constructor(t){typeof t=="function"?this.configProvider=t().then(r=>r||{}):(this.config=t??{},this.configProvider=Promise.resolve(this.config)),T.supported===void 0&&(T.supported=Boolean(typeof Request<"u"&&"keepalive"in new Request("https://[::1]")))}destroy(){}async handle(t,{abortSignal:r}={}){this.config||(this.config=await this.configProvider);const o=this.config.requestTimeout,n=this.config.keepAlive===!0,s=this.config.credentials;if(r?.aborted){const d=new Error("Request aborted");return d.name="AbortError",Promise.reject(d)}let i=t.path;const c=buildQueryString(t.query||{});c&&(i+=`?${c}`),t.fragment&&(i+=`#${t.fragment}`);let u="";if(t.username!=null||t.password!=null){const d=t.username??"",b=t.password??"";u=`${d}:${b}@`}const{port:a,method:f}=t,l=`${t.protocol}//${u}${t.hostname}${a?`:${a}`:""}${i}`,L=f==="GET"||f==="HEAD"?void 0:t.body,y={body:L,headers:new Headers(t.headers),method:f,credentials:s};this.config?.cache&&(y.cache=this.config.cache),L&&(y.duplex="half"),typeof AbortController<"u"&&(y.signal=r),T.supported&&(y.keepalive=n),typeof this.config.requestInit=="function"&&Object.assign(y,this.config.requestInit(t));let x=()=>{};const ue=new Request(l,y),U=[fetch(ue).then(d=>{const b=d.headers,m={};for(const S of b.entries())m[S[0]]=S[1];return d.body!=null?{response:new HttpResponse({headers:m,reason:d.statusText,statusCode:d.status,body:d.body})}:d.blob().then(S=>({response:new HttpResponse({headers:m,reason:d.statusText,statusCode:d.status,body:S})}))}),requestTimeout(o)];return r&&U.push(new Promise((d,b)=>{const m=()=>{const w=new Error("Request aborted");w.name="AbortError",b(w)};if(typeof r.addEventListener=="function"){const w=r;w.addEventListener("abort",m,{once:!0}),x=()=>w.removeEventListener("abort",m)}else r.onabort=m})),Promise.race(U).finally(x)}updateHttpClientConfig(t,r){this.config=void 0,this.configProvider=this.configProvider.then(o=>(o[t]=r,o))}httpHandlerConfigs(){return this.config??{}}}const V=async e=>typeof Blob=="function"&&e instanceof Blob?new Uint8Array(await e.arrayBuffer()):J(e);async function J(e){const t=[],r=e.getReader();let o=!1,n=0;for(;!o;){const{done:c,value:u}=await r.read();u&&(t.push(u),n+=u.length),o=c}const s=new Uint8Array(n);let i=0;for(const c of t)s.set(c,i),i+=c.length;return s}const _={},E={};for(let e=0;e<256;e++){let t=e.toString(16).toLowerCase();t.length===1&&(t=`0${t}`),_[e]=t,E[t]=e}function ye(e){if(e.length%2!==0)throw new Error("Hex encoded strings must have an even number length");const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2){const o=e.slice(r,r+2).toLowerCase();if(o in E)t[r/2]=E[o];else throw new Error(`Cannot decode unrecognized sequence ${o} as hexadecimal`)}return t}function Q(e){let t="";for(let r=0;r<e.byteLength;r++)t+=_[e[r]];return t}const I=e=>typeof ReadableStream=="function"&&(e?.constructor?.name===ReadableStream.name||e instanceof ReadableStream),N="The stream has already been transformed.",X=e=>{if(!O(e)&&!I(e)){const n=e?.__proto__?.constructor?.name||e;throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${n}`)}let t=!1;const r=async()=>{if(t)throw new Error(N);return t=!0,await V(e)},o=n=>{if(typeof n.stream!="function")throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);return n.stream()};return Object.assign(e,{transformToByteArray:r,transformToString:async n=>{const s=await r();if(n==="base64")return(0,C.n)(s);if(n==="hex")return Q(s);if(n===void 0||n==="utf8"||n==="utf-8")return(0,j.Pq)(s);if(typeof TextDecoder=="function")return new TextDecoder(n).decode(s);throw new Error("TextDecoder is not available, please make sure polyfill is provided.")},transformToWebStream:()=>{if(t)throw new Error(N);if(t=!0,O(e))return o(e);if(I(e))return e;throw new Error(`Cannot transform payload to web stream, got ${e}`)}})},O=e=>typeof Blob=="function"&&e instanceof Blob,k="The stream has already been transformed.",q=e=>{if(!(e instanceof g.Readable))try{return X(e)}catch{const n=e?.__proto__?.constructor?.name||e;throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${n}`)}let t=!1;const r=async()=>{if(t)throw new Error(k);return t=!0,await(0,A.kv)(e)};return Object.assign(e,{transformToByteArray:r,transformToString:async o=>{const n=await r();return o===void 0||Buffer.isEncoding(o)?(0,G.Q)(n.buffer,n.byteOffset,n.byteLength).toString(o):new Z.TextDecoder(o).decode(n)},transformToWebStream:()=>{if(t)throw new Error(k);if(e.readableFlowing!==null)throw new Error("The stream has been consumed by other callbacks.");if(typeof g.Readable.toWeb!="function")throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");return t=!0,g.Readable.toWeb(e)}})};async function we(e){if(isReadableStream(e))return splitWebStream(e);const t=new PassThrough,r=new PassThrough;return e.pipe(t),e.pipe(r),[t,r]}const ge=(e,t)=>isReadableStream(e)?headWebStream(e,t):new Promise((r,o)=>{const n=new Y;n.limit=t,e.pipe(n),e.on("error",s=>{n.end(),o(s)}),n.on("error",o),n.on("finish",function(){const s=new Uint8Array(Buffer.concat(this.buffers));r(s)})});class Y extends g.Writable{constructor(){super(...arguments),this.buffers=[],this.limit=1/0,this.bytesBuffered=0}_write(t,r,o){if(this.buffers.push(t),this.bytesBuffered+=t.byteLength??0,this.bytesBuffered>=this.limit){const n=this.bytesBuffered-this.limit,s=this.buffers[this.buffers.length-1];this.buffers[this.buffers.length-1]=s.subarray(0,s.byteLength-n),this.emit("finish")}o()}}class be extends g.Duplex{constructor({expectedChecksum:t,checksum:r,source:o,checksumSourceLocation:n,base64Encoder:s}){if(super(),typeof o.pipe=="function")this.source=o;else throw new Error(`@smithy/util-stream: unsupported source type ${o?.constructor?.name??o} in ChecksumStream.`);this.base64Encoder=s??C.n,this.expectedChecksum=t,this.checksum=r,this.checksumSourceLocation=n,this.source.pipe(this)}_read(t){}_write(t,r,o){try{this.checksum.update(t),this.push(t)}catch(n){return o(n)}return o()}async _final(t){try{const r=await this.checksum.digest(),o=this.base64Encoder(r);if(this.expectedChecksum!==o)return t(new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${o}" in response header "${this.checksumSourceLocation}".`))}catch(r){return t(r)}return this.push(null),t()}}const Se=typeof ReadableStream=="function"?ReadableStream:function(){};class Te extends null{}const Ee=({expectedChecksum:e,checksum:t,source:r,checksumSourceLocation:o,base64Encoder:n})=>{if(!isReadableStream(r))throw new Error(`@smithy/util-stream: unsupported source type ${r?.constructor?.name??r} in ChecksumStream.`);const s=n??toBase64;if(typeof TransformStream!="function")throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");const i=new TransformStream({start(){},async transform(u,a){t.update(u),a.enqueue(u)},async flush(u){const a=await t.digest(),f=s(a);if(e!==f){const l=new Error(`Checksum mismatch: expected "${e}" but received "${f}" in response header "${o}".`);u.error(l)}else u.terminate()}});r.pipeThrough(i);const c=i.readable;return Object.setPrototypeOf(c,ChecksumStream.prototype),c};function Ae(e){return typeof ReadableStream=="function"&&isReadableStream(e.source)?createChecksumStreamWeb(e):new ChecksumStream(e)}function ee(e){return new M.Kd({protocol:e.protocol,hostname:e.hostname,port:Number(e.port),path:e.pathname,query:Array.from(e.searchParams.entries()).reduce((t,[r,o])=>(t[r]=o,t),{}),fragment:e.hash})}async function te(e,t){const o=await q(e.body).transformToString();if(e.statusCode===200){const n=JSON.parse(o);if(typeof n.AccessKeyId!="string"||typeof n.SecretAccessKey!="string"||typeof n.Token!="string"||typeof n.Expiration!="string")throw new p.C1("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }",{logger:t});return{accessKeyId:n.AccessKeyId,secretAccessKey:n.SecretAccessKey,sessionToken:n.Token,expiration:(0,z.EI)(n.Expiration)}}if(e.statusCode>=400&&e.statusCode<500){let n={};try{n=JSON.parse(o)}catch{}throw Object.assign(new p.C1(`Server responded with status: ${e.statusCode}`,{logger:t}),{Code:n.Code,Message:n.Message})}throw new p.C1(`Server responded with status: ${e.statusCode}`,{logger:t})}const re=(e,t,r)=>async()=>{for(let o=0;o<t;++o)try{return await e()}catch{await new Promise(s=>setTimeout(s,r))}return await e()},ne="AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",oe="http://169.254.170.2",se="AWS_CONTAINER_CREDENTIALS_FULL_URI",ae="AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE",ie="AWS_CONTAINER_AUTHORIZATION_TOKEN",ce=(e={})=>{e.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");let t;const r=e.awsContainerCredentialsRelativeUri??process.env[ne],o=e.awsContainerCredentialsFullUri??process.env[se],n=e.awsContainerAuthorizationToken??process.env[ie],s=e.awsContainerAuthorizationTokenFile??process.env[ae],i=e.logger?.constructor?.name==="NoOpLogger"||!e.logger?console.warn:e.logger.warn;if(r&&o&&(i("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."),i("awsContainerCredentialsFullUri will take precedence.")),n&&s&&(i("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."),i("awsContainerAuthorizationToken will take precedence.")),o)t=o;else if(r)t=`${oe}${r}`;else throw new p.C1(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`,{logger:e.logger});const c=new URL(t);K(c,e.logger);const u=new A.$c({requestTimeout:e.timeout??1e3,connectionTimeout:e.timeout??1e3});return re(async()=>{const a=ee(c);n?a.headers.Authorization=n:s&&(a.headers.Authorization=(await $().readFile(s)).toString());try{const f=await u.handle(a);return te(f.response).then(l=>(0,B.g)(l,"CREDENTIALS_HTTP","z"))}catch(f){throw new p.C1(String(f),{logger:e.logger})}},e.maxRetries??3,e.timeout??1e3)}}};
