"use strict";exports.id=661,exports.ids=[661],exports.modules={18661:(Y,P,d)=>{d.d(P,{getInstanceMetadataEndpoint:()=>K,httpRequest:()=>w});var p=d(90779),ee=d(87016),D=d(20181),M=d(58611);function w(e){return new Promise((t,a)=>{const r=(0,M.request)({method:"GET",...e,hostname:e.hostname?.replace(/^\[(.+)\]$/,"$1")});r.on("error",n=>{a(Object.assign(new p.mZ("Unable to connect to instance metadata service"),n)),r.destroy()}),r.on("timeout",()=>{a(new p.mZ("TimeoutError from instance metadata service")),r.destroy()}),r.on("response",n=>{const{statusCode:l=400}=n;(l<200||300<=l)&&(a(Object.assign(new p.mZ("Error response received from instance metadata service"),{statusCode:l})),r.destroy());const u=[];n.on("data",s=>{u.push(s)}),n.on("end",()=>{t(D.Buffer.concat(u)),r.destroy()})}),r.end()})}const _="AWS_CONTAINER_CREDENTIALS_FULL_URI",h="AWS_CONTAINER_CREDENTIALS_RELATIVE_URI",S="AWS_CONTAINER_AUTHORIZATION_TOKEN",te=(e={})=>{const{timeout:t,maxRetries:a}=providerConfigFromInit(e);return()=>retry(async()=>{const r=await F(),n=JSON.parse(await b(t,r));if(!isImdsCredentials(n))throw new CredentialsProviderError("Invalid response received from instance metadata service.");return fromImdsCredentials(n)},a)},b=async(e,t)=>(process.env[S]&&(t.headers={...t.headers,Authorization:process.env[S]}),(await httpRequest({...t,timeout:e})).toString()),R="169.254.170.2",y={localhost:!0,"127.0.0.1":!0},V={"http:":!0,"https:":!0},F=async()=>{if(process.env[h])return{hostname:R,path:process.env[h]};if(process.env[_]){const e=parse(process.env[_]);if(!e.hostname||!(e.hostname in y))throw new CredentialsProviderError(`${e.hostname} is not a valid container metadata service hostname`,!1);if(!e.protocol||!(e.protocol in V))throw new CredentialsProviderError(`${e.protocol} is not a valid container metadata service protocol`,!1);return{...e,port:e.port?parseInt(e.port,10):void 0}}throw new CredentialsProviderError(`The container metadata credential provider cannot be used unless the ${h} or ${_} environment variable is set`,!1)};var C=d(18756);class N extends p.C1{constructor(t,a=!0){super(t,a),this.tryNextLink=a,this.name="InstanceMetadataV1FallbackError",Object.setPrototypeOf(this,N.prototype)}}var k=d(91964),v;(function(e){e.IPv4="http://169.254.169.254",e.IPv6="http://[fd00:ec2::254]"})(v||(v={}));const L="AWS_EC2_METADATA_SERVICE_ENDPOINT",W="ec2_metadata_service_endpoint",U={environmentVariableSelector:e=>e[L],configFileSelector:e=>e[W],default:void 0};var f;(function(e){e.IPv4="IPv4",e.IPv6="IPv6"})(f||(f={}));const $="AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE",x="ec2_metadata_service_endpoint_mode",G={environmentVariableSelector:e=>e[$],configFileSelector:e=>e[x],default:f.IPv4},K=async()=>(0,k.D)(await q()||await B()),q=async()=>(0,C.Z)(U)(),B=async()=>{const e=await(0,C.Z)(G)();switch(e){case f.IPv4:return v.IPv4;case f.IPv6:return v.IPv6;default:throw new Error(`Unsupported endpoint mode: ${e}. Select from ${Object.values(f)}`)}},T="/latest/meta-data/iam/security-credentials/",Z="/latest/api/token",A="AWS_EC2_METADATA_V1_DISABLED",g="ec2_metadata_v1_disabled",O="x-aws-ec2-metadata-token",ae=(e={})=>staticStabilityProvider(H(e),{logger:e.logger}),H=e=>{let t=!1;const{logger:a,profile:r}=e,{timeout:n,maxRetries:l}=providerConfigFromInit(e),u=async(s,E)=>{if(t||E.headers?.[O]==null){let o=!1,i=!1;const Q=await loadConfig({environmentVariableSelector:c=>{const m=c[A];if(i=!!m&&m!=="false",m===void 0)throw new CredentialsProviderError(`${A} not set in env, checking config file next.`);return i},configFileSelector:c=>{const m=c[g];return o=!!m&&m!=="false",o},default:!1},{profile:r})();if(e.ec2MetadataV1Disabled||Q){const c=[];throw e.ec2MetadataV1Disabled&&c.push("credential provider initialization (runtime option ec2MetadataV1Disabled)"),o&&c.push(`config file profile (${g})`),i&&c.push(`process environment variable (${A})`),new InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${c.join(", ")}].`)}}const X=(await retry(async()=>{let o;try{o=await z(E)}catch(i){throw i.statusCode===401&&(t=!1),i}return o},s)).trim();return retry(async()=>{let o;try{o=await J(X,E)}catch(i){throw i.statusCode===401&&(t=!1),i}return o},s)};return async()=>{const s=await getInstanceMetadataEndpoint();if(t)return a?.debug("AWS SDK Instance Metadata","using v1 fallback (no token fetch)"),u(l,{...s,timeout:n});{let E;try{E=(await j({...s,timeout:n})).toString()}catch(I){if(I?.statusCode===400)throw Object.assign(I,{message:"EC2 Metadata token request returned error"});return(I.message==="TimeoutError"||[403,404,405].includes(I.statusCode))&&(t=!0),a?.debug("AWS SDK Instance Metadata","using v1 fallback (initial)"),u(l,{...s,timeout:n})}return u(l,{...s,headers:{[O]:E},timeout:n})}}},j=async e=>httpRequest({...e,path:Z,method:"PUT",headers:{"x-aws-ec2-metadata-token-ttl-seconds":"21600"}}),z=async e=>(await httpRequest({...e,path:T})).toString(),J=async(e,t)=>{const a=JSON.parse((await httpRequest({...t,path:T+e})).toString());if(!isImdsCredentials(a))throw new CredentialsProviderError("Invalid response received from instance metadata service.");return fromImdsCredentials(a)}}};
